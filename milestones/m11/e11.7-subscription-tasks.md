# E11.7 — Subscription Tasks

## Описание

Обновление фоновых задач для автопродления подписок с новой логикой: гибкий период, списание subscription_fee.

---

## Tasks

### T11.7.1 — Update renewal logic

**Описание:** Обновить логику продления подписок.

**Файл:** `backend/src/tasks/subscription_tasks.py`

**Код:**
```python
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_

from src.db.models import User, Tariff
from src.services.token_service import TokenService
from src.services.notification_service import NotificationService
from src.services.payment_service import calculate_next_subscription_end

async def process_subscription_renewals(
    session: AsyncSession,
    notification_service: NotificationService
):
    """
    Обрабатывает продление подписок.

    Для каждой подписки, истекающей сегодня:
    1. Проверить баланс >= subscription_fee
    2. Если да: списать fee, продлить подписку
    3. Если нет: деактивировать, уведомить
    """
    now = datetime.utcnow()
    today_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
    today_end = today_start + timedelta(days=1)

    # Получить активный тариф
    tariff = await session.scalar(
        select(Tariff).where(Tariff.is_active == True)
    )

    # Найти пользователей с истекающей подпиской
    stmt = select(User).where(
        and_(
            User.subscription_end >= today_start,
            User.subscription_end < today_end
        )
    )
    result = await session.execute(stmt)
    users = result.scalars().all()

    token_service = TokenService(session)

    for user in users:
        balance = await token_service.get_balance(user.telegram_id)

        if balance >= tariff.subscription_fee:
            # Достаточно средств — продлить
            await renew_subscription(
                session=session,
                user=user,
                tariff=tariff,
                token_service=token_service,
                notification_service=notification_service
            )
        else:
            # Недостаточно средств — деактивировать
            await deactivate_subscription(
                session=session,
                user=user,
                tariff=tariff,
                balance=balance,
                notification_service=notification_service
            )

    await session.commit()


async def renew_subscription(
    session: AsyncSession,
    user: User,
    tariff: Tariff,
    token_service: TokenService,
    notification_service: NotificationService
):
    """Продлить подписку пользователя."""
    # Списать абонплату
    await token_service.deduct_tokens(
        user_id=user.telegram_id,
        amount=tariff.subscription_fee,
        description="Абонплата за подписку"
    )

    # Рассчитать новую дату окончания
    new_end = calculate_next_subscription_end(
        current_end=user.subscription_end,
        unit=tariff.period_unit,
        value=tariff.period_value
    )

    # Обновить дату подписки
    user.subscription_end = new_end

    # Уведомить пользователя
    new_balance = await token_service.get_balance(user.telegram_id)
    await notification_service.notify_subscription_renewed(
        telegram_id=user.telegram_id,
        subscription_end=new_end.strftime("%d.%m.%Y"),
        subscription_fee=tariff.subscription_fee,
        balance=new_balance
    )


async def deactivate_subscription(
    session: AsyncSession,
    user: User,
    tariff: Tariff,
    balance: int,
    notification_service: NotificationService
):
    """Деактивировать подписку пользователя."""
    # Очистить дату подписки
    user.subscription_end = None

    # Уведомить пользователя
    await notification_service.notify_subscription_deactivated(
        telegram_id=user.telegram_id,
        subscription_fee=tariff.subscription_fee,
        balance=balance
    )
```

**DoD:**
- [ ] Логика продления обновлена
- [ ] Использует subscription_fee из тарифа
- [ ] Использует period_unit для расчёта новой даты
- [ ] Уведомления отправляются

---

### T11.7.2 — Add expiration notifications task

**Описание:** Задача для отправки уведомлений об истечении подписки.

**Файл:** `backend/src/tasks/subscription_tasks.py`

**Код:**
```python
from src.core.config import settings

async def send_expiration_notifications(
    session: AsyncSession,
    notification_service: NotificationService
):
    """
    Отправляет уведомления пользователям об истечении подписки.

    Отправляет за N дней до истечения (настраивается в config).
    """
    now = datetime.utcnow()

    # Получить активный тариф
    tariff = await session.scalar(
        select(Tariff).where(Tariff.is_active == True)
    )

    token_service = TokenService(session)

    for days in settings.SUBSCRIPTION_NOTIFY_DAYS:
        target_date = now + timedelta(days=days)
        target_start = target_date.replace(hour=0, minute=0, second=0, microsecond=0)
        target_end = target_start + timedelta(days=1)

        # Найти пользователей с истечением в этот день
        stmt = select(User).where(
            and_(
                User.subscription_end >= target_start,
                User.subscription_end < target_end
            )
        )
        result = await session.execute(stmt)
        users = result.scalars().all()

        for user in users:
            balance = await token_service.get_balance(user.telegram_id)

            await notification_service.notify_subscription_expiring(
                telegram_id=user.telegram_id,
                days=days,
                balance=balance,
                subscription_fee=tariff.subscription_fee
            )
```

**DoD:**
- [ ] Задача создана
- [ ] Использует SUBSCRIPTION_NOTIFY_DAYS из config
- [ ] Отправляет уведомления за указанное количество дней

---

### T11.7.3 — Schedule tasks

**Описание:** Настроить запуск задач по расписанию.

**Файл:** `backend/src/main.py` или `backend/src/tasks/__init__.py`

**Код (с использованием APScheduler):**
```python
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger

from src.tasks.subscription_tasks import (
    process_subscription_renewals,
    send_expiration_notifications
)

scheduler = AsyncIOScheduler()

# Продление подписок — каждый день в 00:05
scheduler.add_job(
    process_subscription_renewals,
    CronTrigger(hour=0, minute=5),
    id="subscription_renewals",
    replace_existing=True
)

# Уведомления об истечении — каждый день в 10:00
scheduler.add_job(
    send_expiration_notifications,
    CronTrigger(hour=10, minute=0),
    id="expiration_notifications",
    replace_existing=True
)

async def start_scheduler():
    scheduler.start()

async def stop_scheduler():
    scheduler.shutdown()
```

**Альтернатива (без APScheduler):**
```python
import asyncio

async def scheduler_loop():
    while True:
        now = datetime.utcnow()

        # Проверить, нужно ли запустить задачи
        if now.hour == 0 and now.minute == 5:
            await process_subscription_renewals(...)

        if now.hour == 10 and now.minute == 0:
            await send_expiration_notifications(...)

        # Ждать до следующей минуты
        await asyncio.sleep(60)
```

**DoD:**
- [ ] Задачи запускаются по расписанию
- [ ] Продление — ежедневно в 00:05
- [ ] Уведомления — ежедневно в 10:00
- [ ] Scheduler интегрирован в main.py
