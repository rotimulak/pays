# E11.2 — Payment Service

## Описание

Обновление PaymentService для поддержки новой логики: первый платёж списывает абонплату, повторный — вся сумма на баланс.

---

## Tasks

### T11.2.1 — Add subscription status check

**Описание:** Добавить метод проверки активности подписки.

**Файл:** `backend/src/services/payment_service.py`

**Код:**
```python
async def is_subscription_active(self, user_id: int) -> bool:
    """
    Проверяет, активна ли подписка пользователя.

    Returns:
        True если subscription_end > now(), иначе False
    """
    user = await self.user_repo.get_by_telegram_id(user_id)
    if not user or not user.subscription_end:
        return False
    return user.subscription_end > datetime.utcnow()
```

**DoD:**
- [ ] Метод добавлен
- [ ] Обрабатывает случай отсутствия пользователя
- [ ] Обрабатывает случай NULL subscription_end

---

### T11.2.2 — Add subscription activation

**Описание:** Добавить метод активации подписки с расчётом даты окончания.

**Файл:** `backend/src/services/payment_service.py`

**Код:**
```python
async def activate_subscription(
    self,
    user_id: int,
    tariff: Tariff
) -> datetime:
    """
    Активирует подписку пользователя.

    Args:
        user_id: ID пользователя в Telegram
        tariff: Тариф с настройками периода

    Returns:
        Дата окончания подписки
    """
    user = await self.user_repo.get_by_telegram_id(user_id)

    subscription_end = calculate_next_subscription_end(
        current_end=None,  # новая подписка
        unit=tariff.period_unit,
        value=tariff.period_value
    )

    await self.user_repo.update_subscription_end(
        user_id=user.id,
        subscription_end=subscription_end
    )

    return subscription_end
```

**Добавить helper:**
```python
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta

def calculate_next_subscription_end(
    current_end: datetime | None,
    unit: PeriodUnit,
    value: int
) -> datetime:
    base = current_end or datetime.utcnow()

    if unit == PeriodUnit.HOUR:
        return base + timedelta(hours=value)
    elif unit == PeriodUnit.DAY:
        return base + timedelta(days=value)
    elif unit == PeriodUnit.MONTH:
        return base + relativedelta(months=value)
    else:
        raise ValueError(f"Unknown period unit: {unit}")
```

**DoD:**
- [ ] Метод activate_subscription добавлен
- [ ] Helper calculate_next_subscription_end добавлен
- [ ] Добавить зависимость `python-dateutil` в requirements

---

### T11.2.3 — Update process_payment logic

**Описание:** Обновить основную логику обработки платежа.

**Файл:** `backend/src/services/payment_service.py`

**Логика:**
```python
async def process_payment(
    self,
    user_id: int,
    amount: Decimal,
    tariff: Tariff
) -> PaymentResult:
    """
    Обрабатывает платёж с новой логикой.

    Если подписка неактивна:
    - Списываем subscription_fee как абонплату
    - Остаток зачисляем как токены
    - Активируем подписку

    Если подписка активна:
    - Вся сумма → токены на баланс
    """
    is_active = await self.is_subscription_active(user_id)

    # Конвертация: 1 рубль = 1 токен (настраиваемо)
    total_tokens = int(amount)

    if is_active:
        # Повторный платёж — всё на баланс
        tokens_to_credit = total_tokens
        subscription_fee_charged = 0
    else:
        # Первый платёж — списываем абонплату
        subscription_fee_charged = tariff.subscription_fee
        tokens_to_credit = total_tokens - subscription_fee_charged

        # Активируем подписку
        subscription_end = await self.activate_subscription(user_id, tariff)

    # Зачисляем токены
    await self.token_service.credit_tokens(
        user_id=user_id,
        amount=tokens_to_credit,
        description=f"Пополнение баланса ({amount}₽)"
    )

    return PaymentResult(
        tokens_credited=tokens_to_credit,
        subscription_fee=subscription_fee_charged,
        subscription_activated=not is_active,
        subscription_end=subscription_end if not is_active else None
    )
```

**DoD:**
- [ ] Логика первого платежа реализована
- [ ] Логика повторного платежа реализована
- [ ] PaymentResult dataclass обновлён

---

### T11.2.4 — Add PaymentResult dataclass

**Описание:** Создать/обновить dataclass для результата платежа.

**Файл:** `backend/src/services/payment_service.py` или `backend/src/api/schemas/payment.py`

**Код:**
```python
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal

@dataclass
class PaymentResult:
    tokens_credited: int
    subscription_fee: int
    subscription_activated: bool
    subscription_end: datetime | None = None

    @property
    def total_tokens_from_payment(self) -> int:
        """Всего токенов от платежа (включая абонплату)."""
        return self.tokens_credited + self.subscription_fee
```

**DoD:**
- [ ] Dataclass создан
- [ ] Все поля типизированы
- [ ] Используется в process_payment
