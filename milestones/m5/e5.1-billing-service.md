# E5.1 — Billing Service

## Описание

Создание сервиса биллинга для обработки успешных платежей: начисление токенов, продление подписки.

---

## Tasks

### T5.1.1 — Billing service core

**Описание:** Создать основной сервис биллинга.

**Файл:** `backend/src/services/billing_service.py`

**Реализация:**
```python
from uuid import UUID
from datetime import datetime, timedelta
import logging

from sqlalchemy.ext.asyncio import AsyncSession

from db.repositories.invoice_repository import InvoiceRepository
from db.repositories.user_repository import UserRepository
from db.repositories.transaction_repository import TransactionRepository
from db.models.invoice import Invoice, InvoiceStatus
from db.models.transaction import TransactionType
from services.audit_service import AuditService
from services.notification_service import NotificationService
from core.exceptions import NotFoundError, PaymentError

logger = logging.getLogger(__name__)

class BillingService:
    """Service for processing payments and crediting users"""

    def __init__(self, session: AsyncSession):
        self.session = session
        self.invoice_repo = InvoiceRepository(session)
        self.user_repo = UserRepository(session)
        self.transaction_repo = TransactionRepository(session)
        self.audit_service = AuditService(session)
        self.notification_service: NotificationService | None = None

    def set_notification_service(self, service: NotificationService) -> None:
        """Set notification service for sending messages"""
        self.notification_service = service

    async def process_successful_payment(self, invoice_id: UUID) -> Invoice:
        """
        Process successful payment.

        Steps:
        1. Get invoice with lock (FOR UPDATE)
        2. Check idempotency (status != pending → return)
        3. Credit tokens if any
        4. Extend subscription if any
        5. Update invoice status to PAID
        6. Create audit log
        7. Send notification

        Args:
            invoice_id: UUID of paid invoice

        Returns:
            Updated invoice

        Raises:
            NotFoundError: Invoice not found
        """
        # 1. Get invoice with lock
        invoice = await self.invoice_repo.get_for_update(invoice_id)

        if not invoice:
            raise NotFoundError(f"Invoice {invoice_id} not found")

        # 2. Idempotency check
        if invoice.status != InvoiceStatus.PENDING:
            logger.info(
                f"Invoice {invoice_id} already processed, status={invoice.status}"
            )
            return invoice

        # Get user for balance operations
        user = await self.user_repo.get_by_id(invoice.user_id)
        if not user:
            raise NotFoundError(f"User {invoice.user_id} not found")

        old_balance = user.token_balance
        old_subscription = user.subscription_end

        # 3. Credit tokens
        if invoice.tokens > 0:
            await self._credit_tokens(
                user_id=invoice.user_id,
                amount=invoice.tokens,
                invoice_id=invoice.id,
            )

        # 4. Extend subscription
        if invoice.subscription_days > 0:
            await self._extend_subscription(
                user_id=invoice.user_id,
                days=invoice.subscription_days,
                invoice_id=invoice.id,
            )

        # 5. Update invoice status
        invoice.status = InvoiceStatus.PAID
        invoice.paid_at = datetime.utcnow()
        await self.session.flush()

        # 6. Audit log
        await self.audit_service.log_payment_processed(
            user_id=invoice.user_id,
            invoice_id=invoice.id,
            old_balance=old_balance,
            new_balance=user.token_balance,
            old_subscription=old_subscription,
            new_subscription=user.subscription_end,
        )

        # 7. Notification
        if self.notification_service:
            await self.notification_service.notify_payment_success(
                user_id=invoice.user_id,
                invoice=invoice,
            )

        logger.info(
            f"Payment processed: invoice_id={invoice_id}, "
            f"tokens={invoice.tokens}, days={invoice.subscription_days}"
        )

        return invoice
```

**DoD:**
- [ ] process_successful_payment реализован
- [ ] Idempotency через проверку статуса
- [ ] FOR UPDATE lock для invoice
- [ ] Все шаги выполняются в одной транзакции
- [ ] Логирование

---

### T5.1.2 — Credit tokens

**Описание:** Реализовать начисление токенов с optimistic locking.

**Добавление в BillingService:**
```python
async def _credit_tokens(
    self,
    user_id: int,
    amount: int,
    invoice_id: UUID,
) -> None:
    """
    Credit tokens to user balance.

    Uses optimistic locking via balance_version to prevent
    concurrent update issues.

    Args:
        user_id: Telegram user ID
        amount: Number of tokens to add
        invoice_id: Associated invoice ID
    """
    # Get current user state
    user = await self.user_repo.get_by_id(user_id)
    if not user:
        raise NotFoundError(f"User {user_id} not found")

    # Update balance with optimistic locking
    # This will retry if version mismatch
    new_balance = await self.user_repo.update_balance(
        user_id=user_id,
        delta=amount,
        expected_version=user.balance_version,
    )

    # Create transaction record
    await self.transaction_repo.create_transaction(
        user_id=user_id,
        type=TransactionType.TOPUP,
        tokens_delta=amount,
        balance_after=new_balance,
        description=f"Пополнение баланса",
        invoice_id=invoice_id,
    )

    logger.info(
        f"Tokens credited: user_id={user_id}, amount={amount}, "
        f"new_balance={new_balance}"
    )
```

**Optimistic locking в UserRepository:**
```python
async def update_balance(
    self,
    user_id: int,
    delta: int,
    expected_version: int,
    max_retries: int = 3,
) -> int:
    """
    Update user balance with optimistic locking.

    Args:
        user_id: User ID
        delta: Amount to add (can be negative for spending)
        expected_version: Expected balance_version
        max_retries: Number of retries on version conflict

    Returns:
        New balance after update

    Raises:
        OptimisticLockError: Version conflict after max retries
    """
    for attempt in range(max_retries):
        result = await self.session.execute(
            update(User)
            .where(User.id == user_id)
            .where(User.balance_version == expected_version + attempt)
            .values(
                token_balance=User.token_balance + delta,
                balance_version=User.balance_version + 1,
            )
            .returning(User.token_balance)
        )

        row = result.fetchone()
        if row:
            return row[0]

        # Refresh user and retry
        await self.session.refresh(user)
        expected_version = user.balance_version

    raise OptimisticLockError(
        f"Failed to update balance for user {user_id} after {max_retries} retries"
    )
```

**DoD:**
- [ ] Токены начисляются корректно
- [ ] Optimistic locking работает
- [ ] Transaction record создаётся
- [ ] Unit-тесты для concurrent updates

---

### T5.1.3 — Extend subscription

**Описание:** Реализовать продление подписки.

**Добавление в BillingService:**
```python
async def _extend_subscription(
    self,
    user_id: int,
    days: int,
    invoice_id: UUID,
) -> datetime:
    """
    Extend user subscription.

    If subscription is active, add days to current end date.
    If subscription expired or not set, start from now.

    Args:
        user_id: Telegram user ID
        days: Number of days to add
        invoice_id: Associated invoice ID

    Returns:
        New subscription end date
    """
    user = await self.user_repo.get_by_id(user_id)
    if not user:
        raise NotFoundError(f"User {user_id} not found")

    now = datetime.utcnow()

    # Calculate new end date
    if user.subscription_end and user.subscription_end > now:
        # Extend from current end
        new_end = user.subscription_end + timedelta(days=days)
    else:
        # Start fresh from now
        new_end = now + timedelta(days=days)

    # Update subscription
    await self.user_repo.update_subscription(user_id, new_end)

    # Create transaction record (0 tokens, just for history)
    await self.transaction_repo.create_transaction(
        user_id=user_id,
        type=TransactionType.TOPUP,
        tokens_delta=0,
        balance_after=user.token_balance,
        description=f"Подписка продлена на {days} дней",
        invoice_id=invoice_id,
        metadata={"subscription_days": days, "new_end": new_end.isoformat()},
    )

    logger.info(
        f"Subscription extended: user_id={user_id}, days={days}, "
        f"new_end={new_end}"
    )

    return new_end
```

**Логика продления:**
```
Сценарий 1: Подписка активна (end > now)
- Новое окончание = текущее окончание + дни

Сценарий 2: Подписка истекла или не было
- Новое окончание = сейчас + дни
```

**DoD:**
- [ ] Подписка продлевается правильно
- [ ] Обрабатывает активную подписку
- [ ] Обрабатывает истёкшую/отсутствующую подписку
- [ ] Transaction создаётся с metadata
- [ ] Unit-тесты для обоих сценариев
