# E4.2 ‚Äî Mock Provider

## –û–ø–∏—Å–∞–Ω–∏–µ

–†–µ–∞–ª–∏–∑–∞—Ü–∏—è MockPaymentProvider —Å —Ç–µ–º –∂–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º, —á—Ç–æ –∏ Robokassa.

---

## Tasks

### T4.2.1 ‚Äî Mock provider implementation

**–û–ø–∏—Å–∞–Ω–∏–µ:** –°–æ–∑–¥–∞—Ç—å MockPaymentProvider –∫–ª–∞—Å—Å.

**–§–∞–π–ª:** `backend/src/payments/providers/mock/provider.py`

**–†–µ–∞–ª–∏–∑–∞—Ü–∏—è:**
```python
from decimal import Decimal
from urllib.parse import urlencode
from uuid import UUID

from payments.providers.base import PaymentProvider
from payments.schemas import WebhookData, PaymentInitParams
from payments.providers.mock.signature import generate_init_signature, generate_result_signature
from db.models.invoice import Invoice
from core.config import settings

class MockPaymentProvider(PaymentProvider):
    """
    Mock payment provider that mimics Robokassa behavior.
    Used for testing without real payment integration.
    """

    def __init__(
        self,
        merchant_login: str,
        password_1: str,
        password_2: str,
        base_url: str,
    ):
        self.merchant_login = merchant_login
        self.password_1 = password_1
        self.password_2 = password_2
        self.base_url = base_url

    def generate_payment_url(self, invoice: Invoice) -> str:
        """
        Generate mock payment URL.

        URL format matches Robokassa:
        {base_url}/mock-payment?MerchantLogin=...&OutSum=...&InvId=...
        &Description=...&SignatureValue=...&Shp_invoice_id=...&Shp_user_id=...
        """
        shp_params = {
            "Shp_invoice_id": str(invoice.id),
            "Shp_user_id": str(invoice.user_id),
        }

        signature = generate_init_signature(
            merchant_login=self.merchant_login,
            out_sum=invoice.amount,
            inv_id=invoice.inv_id,
            password=self.password_1,
            shp_params=shp_params,
        )

        params = {
            "MerchantLogin": self.merchant_login,
            "OutSum": str(invoice.amount),
            "InvId": str(invoice.inv_id),
            "Description": f"–û–ø–ª–∞—Ç–∞ —Ç–∞—Ä–∏—Ñ–∞",  # TODO: get from tariff
            "SignatureValue": signature,
            **shp_params,
        }

        return f"{self.base_url}/mock-payment?{urlencode(params)}"

    def verify_result_signature(self, data: WebhookData) -> bool:
        """Verify webhook signature using Password_2"""
        shp_params = {
            "Shp_invoice_id": str(data.shp_invoice_id),
            "Shp_user_id": str(data.shp_user_id),
        }

        expected = generate_result_signature(
            out_sum=data.out_sum,
            inv_id=data.inv_id,
            password=self.password_2,
            shp_params=shp_params,
        )

        return data.signature.lower() == expected.lower()

    def parse_webhook(self, raw_data: dict) -> WebhookData:
        """Parse form data to WebhookData"""
        return WebhookData(
            out_sum=Decimal(raw_data["OutSum"]),
            inv_id=int(raw_data["InvId"]),
            signature=raw_data["SignatureValue"],
            shp_invoice_id=UUID(raw_data["Shp_invoice_id"]),
            shp_user_id=int(raw_data["Shp_user_id"]),
            fee=Decimal(raw_data["Fee"]) if "Fee" in raw_data else None,
            email=raw_data.get("EMail"),
            payment_method=raw_data.get("PaymentMethod"),
        )

    def format_success_response(self, inv_id: int) -> str:
        """Return OK{InvId}"""
        return f"OK{inv_id}"

    def get_provider_name(self) -> str:
        return "mock"
```

**DoD:**
- [ ] –í—Å–µ –º–µ—Ç–æ–¥—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã
- [ ] URL –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
- [ ] –ü–æ–¥–ø–∏—Å–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è/–≤–µ—Ä–∏—Ñ–∏—Ü–∏—Ä—É—é—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
- [ ] parse_webhook –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—Å–µ –ø–æ–ª—è

---

### T4.2.2 ‚Äî Signature utilities

**–û–ø–∏—Å–∞–Ω–∏–µ:** –°–æ–∑–¥–∞—Ç—å —É—Ç–∏–ª–∏—Ç—ã –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–µ–π.

**–§–∞–π–ª:** `backend/src/payments/providers/mock/signature.py`

**–†–µ–∞–ª–∏–∑–∞—Ü–∏—è:**
```python
import hashlib
from decimal import Decimal

def generate_init_signature(
    merchant_login: str,
    out_sum: Decimal,
    inv_id: int,
    password: str,
    shp_params: dict[str, str] | None = None,
) -> str:
    """
    Generate signature for payment URL.

    Formula without Shp_*:
        MD5(MerchantLogin:OutSum:InvId:Password_1)

    Formula with Shp_* (sorted alphabetically):
        MD5(MerchantLogin:OutSum:InvId:Password_1:Shp_a=x:Shp_b=y)
    """
    # Format OutSum: always with 2 decimal places
    out_sum_str = f"{out_sum:.2f}"

    parts = [merchant_login, out_sum_str, str(inv_id), password]

    if shp_params:
        # Sort by key alphabetically
        sorted_shp = sorted(shp_params.items())
        for key, value in sorted_shp:
            parts.append(f"{key}={value}")

    signature_string = ":".join(parts)
    return hashlib.md5(signature_string.encode()).hexdigest()

def generate_result_signature(
    out_sum: Decimal,
    inv_id: int,
    password: str,
    shp_params: dict[str, str] | None = None,
) -> str:
    """
    Generate signature for ResultURL verification.

    Formula without Shp_*:
        MD5(OutSum:InvId:Password_2)

    Formula with Shp_* (sorted alphabetically):
        MD5(OutSum:InvId:Password_2:Shp_a=x:Shp_b=y)
    """
    out_sum_str = f"{out_sum:.2f}"

    parts = [out_sum_str, str(inv_id), password]

    if shp_params:
        sorted_shp = sorted(shp_params.items())
        for key, value in sorted_shp:
            parts.append(f"{key}={value}")

    signature_string = ":".join(parts)
    return hashlib.md5(signature_string.encode()).hexdigest()

def verify_signature(
    signature: str,
    expected: str,
) -> bool:
    """Case-insensitive signature comparison"""
    return signature.lower() == expected.lower()
```

**–ü—Ä–∏–º–µ—Ä—ã:**
```python
# Init signature example:
# merchant=demo, sum=100.00, inv_id=1, pass=secret
# Shp_invoice_id=abc-123, Shp_user_id=456
# ‚Üí MD5("demo:100.00:1:secret:Shp_invoice_id=abc-123:Shp_user_id=456")

# Result signature example:
# sum=100.00, inv_id=1, pass=secret2
# Shp_invoice_id=abc-123, Shp_user_id=456
# ‚Üí MD5("100.00:1:secret2:Shp_invoice_id=abc-123:Shp_user_id=456")
```

**DoD:**
- [ ] Init signature –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ
- [ ] Result signature –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ
- [ ] Shp_* —Å–æ—Ä—Ç–∏—Ä—É—é—Ç—Å—è –∞–ª—Ñ–∞–≤–∏—Ç–Ω–æ
- [ ] OutSum —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç—Å—è —Å 2 –∑–Ω–∞–∫–∞–º–∏ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π
- [ ] Unit-—Ç–µ—Å—Ç—ã —Å –∏–∑–≤–µ—Å—Ç–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏

---

### T4.2.3 ‚Äî Mock payment UI

**–û–ø–∏—Å–∞–Ω–∏–µ:** –°–æ–∑–¥–∞—Ç—å FastAPI —Ä–æ—É—Ç–µ—Ä –∏ HTML —à–∞–±–ª–æ–Ω—ã –¥–ª—è mock UI.

**–§–∞–π–ª—ã:**
- `backend/src/payments/providers/mock/router.py`
- `backend/src/payments/providers/mock/templates/payment_page.html`
- `backend/src/payments/providers/mock/templates/success.html`
- `backend/src/payments/providers/mock/templates/fail.html`

**Router:**
```python
from fastapi import APIRouter, Request, Form
from fastapi.responses import HTMLResponse, RedirectResponse
from fastapi.templating import Jinja2Templates
import httpx

router = APIRouter(prefix="/mock-payment", tags=["mock-payment"])
templates = Jinja2Templates(directory="payments/providers/mock/templates")

@router.get("", response_class=HTMLResponse)
async def payment_page(
    request: Request,
    MerchantLogin: str,
    OutSum: str,
    InvId: int,
    Description: str,
    SignatureValue: str,
    Shp_invoice_id: str,
    Shp_user_id: int,
):
    """
    Mock payment page.
    Shows amount and buttons to simulate payment or cancel.
    """
    return templates.TemplateResponse(
        "payment_page.html",
        {
            "request": request,
            "merchant": MerchantLogin,
            "amount": OutSum,
            "inv_id": InvId,
            "description": Description,
            "signature": SignatureValue,
            "invoice_id": Shp_invoice_id,
            "user_id": Shp_user_id,
        }
    )

@router.post("/process")
async def process_payment(
    OutSum: str = Form(...),
    InvId: int = Form(...),
    Shp_invoice_id: str = Form(...),
    Shp_user_id: int = Form(...),
):
    """
    Simulate successful payment.
    1. Generate ResultURL signature
    2. POST to webhook endpoint
    3. Redirect to SuccessURL
    """
    # Generate signature for webhook
    signature = generate_result_signature(...)

    # Call webhook
    async with httpx.AsyncClient() as client:
        await client.post(
            f"{settings.WEBHOOK_BASE_URL}/webhook/robokassa",
            data={
                "OutSum": OutSum,
                "InvId": InvId,
                "SignatureValue": signature,
                "Shp_invoice_id": Shp_invoice_id,
                "Shp_user_id": Shp_user_id,
            }
        )

    return RedirectResponse(url="/mock-payment/success", status_code=303)

@router.post("/cancel")
async def cancel_payment():
    """Simulate cancelled payment"""
    return RedirectResponse(url="/mock-payment/fail", status_code=303)

@router.get("/success", response_class=HTMLResponse)
async def success_page(request: Request):
    """Success page after payment"""
    return templates.TemplateResponse("success.html", {"request": request})

@router.get("/fail", response_class=HTMLResponse)
async def fail_page(request: Request):
    """Fail page after cancel"""
    return templates.TemplateResponse("fail.html", {"request": request})
```

**payment_page.html:**
```html
<!DOCTYPE html>
<html>
<head>
    <title>Mock Payment</title>
    <style>
        body { font-family: Arial; max-width: 400px; margin: 50px auto; padding: 20px; }
        .amount { font-size: 32px; font-weight: bold; margin: 20px 0; }
        .btn { padding: 15px 30px; font-size: 18px; cursor: pointer; margin: 10px; }
        .btn-pay { background: #4CAF50; color: white; border: none; }
        .btn-cancel { background: #f44336; color: white; border: none; }
    </style>
</head>
<body>
    <h1>üè¶ Mock Payment</h1>
    <p>Merchant: {{ merchant }}</p>
    <p>{{ description }}</p>
    <div class="amount">{{ amount }} ‚ÇΩ</div>

    <form action="/mock-payment/process" method="post">
        <input type="hidden" name="OutSum" value="{{ amount }}">
        <input type="hidden" name="InvId" value="{{ inv_id }}">
        <input type="hidden" name="Shp_invoice_id" value="{{ invoice_id }}">
        <input type="hidden" name="Shp_user_id" value="{{ user_id }}">
        <button type="submit" class="btn btn-pay">‚úì –û–ø–ª–∞—Ç–∏—Ç—å</button>
    </form>

    <form action="/mock-payment/cancel" method="post">
        <button type="submit" class="btn btn-cancel">‚úó –û—Ç–º–µ–Ω–∏—Ç—å</button>
    </form>
</body>
</html>
```

**DoD:**
- [ ] Payment page –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å—É–º–º—É –∏ –æ–ø–∏—Å–∞–Ω–∏–µ
- [ ] –ö–Ω–æ–ø–∫–∞ "–û–ø–ª–∞—Ç–∏—Ç—å" –≤—ã–∑—ã–≤–∞–µ—Ç webhook
- [ ] –ö–Ω–æ–ø–∫–∞ "–û—Ç–º–µ–Ω–∏—Ç—å" –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç fail page
- [ ] –ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è success page
- [ ] –®–∞–±–ª–æ–Ω—ã —Å—Ç–∏–ª–∏–∑–æ–≤–∞–Ω—ã –º–∏–Ω–∏–º–∞–ª—å–Ω–æ
