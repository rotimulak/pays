# E8.3 — Guards & Validation

## Описание

Проверки и ограничения для безопасного списания токенов.

---

## Tasks

### T8.3.1 — Spending guards

**Описание:** Создать guards для проверки условий списания.

**Файл:** `backend/src/services/guards/spending_guards.py`

**Реализация:**
```python
from datetime import datetime
from dataclasses import dataclass

from db.models.user import User
from core.exceptions import (
    SubscriptionExpiredError,
    InsufficientBalanceError,
    UserBlockedError,
)

@dataclass
class SpendingContext:
    """Context for spending validation"""
    user: User
    amount: int
    description: str

class SpendingGuard:
    """Guard for validating token spending"""

    def __init__(self, context: SpendingContext):
        self.context = context
        self.user = context.user
        self.amount = context.amount

    def validate_all(self) -> None:
        """Run all validations. Raises on failure."""
        self.check_user_not_blocked()
        self.check_subscription_active()
        self.check_sufficient_balance()

    def check_user_not_blocked(self) -> None:
        """Check user is not blocked"""
        if self.user.is_blocked:
            raise UserBlockedError(
                f"User {self.user.id} is blocked"
            )

    def check_subscription_active(self) -> None:
        """Check user has active subscription"""
        now = datetime.utcnow()

        if self.user.subscription_end is None:
            raise SubscriptionExpiredError(
                "No subscription. Please purchase a plan."
            )

        if self.user.subscription_end <= now:
            raise SubscriptionExpiredError(
                f"Subscription expired on {self.user.subscription_end.strftime('%d.%m.%Y')}"
            )

    def check_sufficient_balance(self) -> None:
        """Check user has enough tokens"""
        if self.user.token_balance < self.amount:
            raise InsufficientBalanceError(
                required=self.amount,
                available=self.user.token_balance,
            )

    def check_spending_limit(self, daily_limit: int = 1000) -> None:
        """
        Optional: Check daily spending limit.
        Prevents runaway spending bugs.
        """
        # TODO: Implement daily spending tracking
        pass

def validate_spending(user: User, amount: int, description: str) -> None:
    """
    Convenience function for spending validation.

    Raises appropriate exception on validation failure.
    """
    context = SpendingContext(user=user, amount=amount, description=description)
    guard = SpendingGuard(context)
    guard.validate_all()
```

**Новые exceptions:**
```python
# core/exceptions.py

class UserBlockedError(AppException):
    """User is blocked from spending"""
    pass

class InsufficientBalanceError(AppException):
    """Not enough tokens"""
    def __init__(self, required: int, available: int):
        self.required = required
        self.available = available
        super().__init__(
            f"Insufficient balance: need {required}, have {available}"
        )

class SubscriptionExpiredError(AppException):
    """Subscription is expired"""
    pass
```

**DoD:**
- [ ] SpendingGuard с всеми проверками
- [ ] UserBlockedError для заблокированных
- [ ] Понятные сообщения об ошибках
- [ ] Optional daily limit check

---

### T8.3.2 — Rate limiting

**Описание:** Добавить rate limiting для API.

**Файл:** `backend/src/api/middleware/rate_limit.py`

**Реализация:**
```python
from datetime import datetime, timedelta
from collections import defaultdict
import asyncio

from fastapi import Request, HTTPException, status
from starlette.middleware.base import BaseHTTPMiddleware

class RateLimitMiddleware(BaseHTTPMiddleware):
    """
    Simple in-memory rate limiter.
    For production, use Redis-based solution.
    """

    def __init__(self, app, calls: int = 100, period: int = 60):
        super().__init__(app)
        self.calls = calls  # Max calls per period
        self.period = period  # Period in seconds
        self.requests: dict[str, list[datetime]] = defaultdict(list)
        self._lock = asyncio.Lock()

    async def dispatch(self, request: Request, call_next):
        # Skip rate limiting for non-API routes
        if not request.url.path.startswith("/api/"):
            return await call_next(request)

        # Get client identifier (API key or IP)
        client_id = self._get_client_id(request)

        # Check rate limit
        async with self._lock:
            if not self._is_allowed(client_id):
                raise HTTPException(
                    status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                    detail={
                        "error": "rate_limited",
                        "message": f"Too many requests. Limit: {self.calls} per {self.period}s",
                        "retry_after": self.period,
                    },
                    headers={"Retry-After": str(self.period)},
                )

            self._record_request(client_id)

        return await call_next(request)

    def _get_client_id(self, request: Request) -> str:
        """Get client identifier for rate limiting"""
        # Prefer API key if present
        auth = request.headers.get("Authorization", "")
        if auth.startswith("Bearer "):
            return f"key:{auth[7:]}"

        # Fall back to IP
        forwarded = request.headers.get("X-Forwarded-For")
        if forwarded:
            return f"ip:{forwarded.split(',')[0].strip()}"

        return f"ip:{request.client.host}"

    def _is_allowed(self, client_id: str) -> bool:
        """Check if request is within rate limit"""
        now = datetime.utcnow()
        cutoff = now - timedelta(seconds=self.period)

        # Clean old requests
        self.requests[client_id] = [
            t for t in self.requests[client_id]
            if t > cutoff
        ]

        return len(self.requests[client_id]) < self.calls

    def _record_request(self, client_id: str) -> None:
        """Record new request"""
        self.requests[client_id].append(datetime.utcnow())

# Usage in FastAPI app:
# app.add_middleware(RateLimitMiddleware, calls=100, period=60)
```

**Endpoint-specific rate limiting:**
```python
# api/routes/tokens.py

from api.middleware.rate_limit import RateLimiter

# Create limiter for spend endpoint (stricter)
spend_limiter = RateLimiter(calls=10, period=60)

@router.post("/users/{user_id}/spend")
async def spend_tokens(
    user_id: int,
    request: SpendTokensRequest,
    session: AsyncSession = Depends(get_session),
    _api_key: str = Depends(verify_api_key),
    _rate_limit: None = Depends(spend_limiter),
) -> SpendTokensResponse:
    # ...
```

**DoD:**
- [ ] Global rate limit middleware
- [ ] Per-endpoint rate limiting
- [ ] 429 response with Retry-After
- [ ] Rate limit by API key or IP
