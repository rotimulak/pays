# E8.1 — Token Service

## Описание

Сервис для расходования токенов с полной поддержкой idempotency и optimistic locking.

---

## Tasks

### T8.1.1 — Token service core

**Описание:** Создать сервис для работы с токенами.

**Файл:** `backend/src/services/token_service.py`

**Реализация:**
```python
from uuid import UUID
from datetime import datetime
from dataclasses import dataclass
import logging

from sqlalchemy.ext.asyncio import AsyncSession

from db.repositories.user_repository import UserRepository
from db.repositories.transaction_repository import TransactionRepository
from db.models.transaction import Transaction, TransactionType
from db.models.user import User
from core.exceptions import (
    InsufficientBalanceError,
    SubscriptionExpiredError,
    NotFoundError,
    ConcurrentModificationError,
)

logger = logging.getLogger(__name__)

@dataclass
class TokenBalance:
    """Current token balance state"""
    user_id: int
    token_balance: int
    subscription_active: bool
    subscription_end: datetime | None
    can_spend: bool
    reason: str | None = None  # Why can't spend

@dataclass
class SpendResult:
    """Result of token spending"""
    transaction_id: UUID
    tokens_spent: int
    balance_before: int
    balance_after: int
    user_id: int

class TokenService:
    """Service for token operations"""

    def __init__(self, session: AsyncSession):
        self.session = session
        self.user_repo = UserRepository(session)
        self.transaction_repo = TransactionRepository(session)

    async def check_balance(self, user_id: int) -> TokenBalance:
        """
        Check user's token balance and spending eligibility.

        Args:
            user_id: Telegram user ID

        Returns:
            TokenBalance with current state

        Raises:
            NotFoundError: User not found
        """
        user = await self.user_repo.get_by_id(user_id)
        if not user:
            raise NotFoundError(f"User {user_id} not found")

        now = datetime.utcnow()
        subscription_active = (
            user.subscription_end is not None and
            user.subscription_end > now
        )

        can_spend = True
        reason = None

        if not subscription_active:
            can_spend = False
            reason = "Subscription expired"
        elif user.token_balance <= 0:
            can_spend = False
            reason = "Insufficient balance"

        return TokenBalance(
            user_id=user.id,
            token_balance=user.token_balance,
            subscription_active=subscription_active,
            subscription_end=user.subscription_end,
            can_spend=can_spend,
            reason=reason,
        )

    async def can_spend(self, user_id: int, amount: int) -> tuple[bool, str | None]:
        """
        Check if user can spend specified amount.

        Args:
            user_id: Telegram user ID
            amount: Amount to spend

        Returns:
            (can_spend, reason)
        """
        balance = await self.check_balance(user_id)

        if not balance.subscription_active:
            return False, "Subscription expired"

        if balance.token_balance < amount:
            return False, f"Insufficient balance (need {amount}, have {balance.token_balance})"

        return True, None

    async def spend_tokens(
        self,
        user_id: int,
        amount: int,
        description: str,
        idempotency_key: str | None = None,
        metadata: dict | None = None,
    ) -> SpendResult:
        """
        Spend tokens from user's balance.

        Args:
            user_id: Telegram user ID
            amount: Amount to spend (positive)
            description: Description for transaction
            idempotency_key: Optional key for idempotency
            metadata: Optional additional data

        Returns:
            SpendResult with transaction details

        Raises:
            NotFoundError: User not found
            SubscriptionExpiredError: No active subscription
            InsufficientBalanceError: Not enough tokens
            ConcurrentModificationError: Race condition detected
        """
        if amount <= 0:
            raise ValueError("Amount must be positive")

        # Check idempotency
        if idempotency_key:
            existing = await self.transaction_repo.get_by_idempotency(idempotency_key)
            if existing:
                logger.info(f"Returning existing transaction: {existing.id}")
                return SpendResult(
                    transaction_id=existing.id,
                    tokens_spent=-existing.tokens_delta,
                    balance_before=existing.balance_after - existing.tokens_delta,
                    balance_after=existing.balance_after,
                    user_id=user_id,
                )

        # Get user with lock
        user = await self.user_repo.get_for_update(user_id)
        if not user:
            raise NotFoundError(f"User {user_id} not found")

        # Check subscription
        now = datetime.utcnow()
        if not user.subscription_end or user.subscription_end <= now:
            raise SubscriptionExpiredError(
                f"Subscription expired on {user.subscription_end}"
            )

        # Check balance
        if user.token_balance < amount:
            raise InsufficientBalanceError(
                required=amount,
                available=user.token_balance,
            )

        balance_before = user.token_balance
        new_balance = balance_before - amount

        # Update balance with optimistic locking
        try:
            await self.user_repo.update_balance(
                user_id=user_id,
                delta=-amount,
                expected_version=user.balance_version,
            )
        except OptimisticLockError:
            raise ConcurrentModificationError(
                "Balance was modified by another request. Please retry."
            )

        # Create transaction
        transaction = await self.transaction_repo.create(
            user_id=user_id,
            type=TransactionType.SPEND,
            tokens_delta=-amount,
            balance_after=new_balance,
            description=description,
            idempotency_key=idempotency_key,
            metadata=metadata,
        )

        logger.info(
            f"Tokens spent: user={user_id}, amount={amount}, "
            f"balance={balance_before}→{new_balance}"
        )

        return SpendResult(
            transaction_id=transaction.id,
            tokens_spent=amount,
            balance_before=balance_before,
            balance_after=new_balance,
            user_id=user_id,
        )
```

**DoD:**
- [ ] check_balance возвращает полное состояние
- [ ] can_spend проверяет все условия
- [ ] spend_tokens с idempotency
- [ ] Optimistic locking
- [ ] Логирование

---

### T8.1.2 — Idempotency support

**Описание:** Добавить поддержку idempotency в транзакции.

**Обновление модели Transaction:**
```python
# db/models/transaction.py
class Transaction(Base):
    # ... existing fields ...

    idempotency_key: Mapped[str | None] = mapped_column(
        String(255),
        unique=True,
        nullable=True,
        index=True,
    )
```

**Обновление репозитория:**
```python
# db/repositories/transaction_repository.py
async def get_by_idempotency(self, key: str) -> Transaction | None:
    """Get transaction by idempotency key"""
    result = await self.session.execute(
        select(Transaction).where(Transaction.idempotency_key == key)
    )
    return result.scalar_one_or_none()

async def create(
    self,
    user_id: int,
    type: TransactionType,
    tokens_delta: int,
    balance_after: int,
    description: str | None = None,
    invoice_id: UUID | None = None,
    idempotency_key: str | None = None,
    metadata: dict | None = None,
) -> Transaction:
    """Create transaction with optional idempotency key"""
    transaction = Transaction(
        id=uuid4(),
        user_id=user_id,
        type=type,
        tokens_delta=tokens_delta,
        balance_after=balance_after,
        description=description,
        invoice_id=invoice_id,
        idempotency_key=idempotency_key,
        metadata=metadata or {},
        created_at=datetime.utcnow(),
    )
    self.session.add(transaction)
    await self.session.flush()
    return transaction
```

**DoD:**
- [ ] idempotency_key в Transaction
- [ ] Unique constraint на idempotency_key
- [ ] get_by_idempotency в репозитории
- [ ] Миграция для нового поля

---

### T8.1.3 — Concurrent spending tests

**Описание:** Написать тесты для concurrent spending.

**Файл:** `backend/tests/test_token_service_concurrent.py`

**Тесты:**
```python
import asyncio
import pytest
from decimal import Decimal

from services.token_service import TokenService
from core.exceptions import InsufficientBalanceError, ConcurrentModificationError

@pytest.mark.asyncio
async def test_concurrent_spending_same_amount():
    """
    Test that concurrent spending of same amount
    results in only one successful transaction.
    """
    # Setup: user with 100 tokens
    user_id = await create_test_user(token_balance=100)

    async def spend_50():
        async with get_session() as session:
            service = TokenService(session)
            try:
                return await service.spend_tokens(user_id, 50, "test")
            except InsufficientBalanceError:
                return None

    # Run 3 concurrent spends of 50 tokens
    results = await asyncio.gather(
        spend_50(), spend_50(), spend_50(),
        return_exceptions=True
    )

    # Should have exactly 2 successful spends (100 / 50 = 2)
    successful = [r for r in results if r is not None and not isinstance(r, Exception)]
    assert len(successful) == 2

    # Final balance should be 0
    balance = await get_user_balance(user_id)
    assert balance == 0

@pytest.mark.asyncio
async def test_idempotency_prevents_double_spend():
    """
    Test that same idempotency key prevents double spending.
    """
    user_id = await create_test_user(token_balance=100)
    idempotency_key = "unique-key-123"

    async with get_session() as session:
        service = TokenService(session)

        # First spend
        result1 = await service.spend_tokens(
            user_id, 50, "test",
            idempotency_key=idempotency_key,
        )

        # Second spend with same key
        result2 = await service.spend_tokens(
            user_id, 50, "test",
            idempotency_key=idempotency_key,
        )

    # Should return same transaction
    assert result1.transaction_id == result2.transaction_id

    # Balance should be 50 (not 0)
    balance = await get_user_balance(user_id)
    assert balance == 50

@pytest.mark.asyncio
async def test_subscription_check_under_load():
    """
    Test subscription validation under concurrent load.
    """
    # User with expired subscription
    user_id = await create_test_user(
        token_balance=1000,
        subscription_end=datetime.utcnow() - timedelta(days=1),
    )

    async def try_spend():
        async with get_session() as session:
            service = TokenService(session)
            try:
                await service.spend_tokens(user_id, 10, "test")
                return "success"
            except SubscriptionExpiredError:
                return "expired"

    # All should fail with SubscriptionExpiredError
    results = await asyncio.gather(*[try_spend() for _ in range(10)])

    assert all(r == "expired" for r in results)
```

**DoD:**
- [ ] Тест concurrent spending
- [ ] Тест idempotency
- [ ] Тест subscription check
- [ ] Все тесты проходят
