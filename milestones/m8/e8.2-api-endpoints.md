# E8.2 — API Endpoints

## Описание

REST API для проверки баланса и списания токенов.

---

## Tasks

### T8.2.1 — Token API schemas

**Описание:** Создать Pydantic схемы для API.

**Файл:** `backend/src/api/schemas/tokens.py`

**Реализация:**
```python
from pydantic import BaseModel, Field
from uuid import UUID
from datetime import datetime

class TokenBalanceResponse(BaseModel):
    """Response for balance check"""
    user_id: int
    token_balance: int = Field(..., ge=0)
    subscription_active: bool
    subscription_end: datetime | None
    can_spend: bool
    reason: str | None = None

    class Config:
        from_attributes = True

class SpendTokensRequest(BaseModel):
    """Request to spend tokens"""
    amount: int = Field(..., gt=0, le=10000, description="Amount to spend")
    description: str = Field(..., min_length=1, max_length=500)
    idempotency_key: str | None = Field(
        None,
        min_length=1,
        max_length=255,
        description="Unique key to prevent duplicate spending",
    )
    metadata: dict | None = Field(None, description="Additional data")

class SpendTokensResponse(BaseModel):
    """Response after spending tokens"""
    success: bool = True
    transaction_id: UUID
    tokens_spent: int
    balance_before: int
    balance_after: int

class ErrorResponse(BaseModel):
    """Error response"""
    error: str  # Error code: insufficient_balance, subscription_expired, etc.
    message: str  # Human-readable message
    details: dict | None = None

# Error codes
class TokenErrorCode:
    INSUFFICIENT_BALANCE = "insufficient_balance"
    SUBSCRIPTION_EXPIRED = "subscription_expired"
    USER_NOT_FOUND = "user_not_found"
    INVALID_AMOUNT = "invalid_amount"
    RATE_LIMITED = "rate_limited"
```

**DoD:**
- [ ] TokenBalanceResponse
- [ ] SpendTokensRequest с валидацией
- [ ] SpendTokensResponse
- [ ] ErrorResponse с кодами ошибок

---

### T8.2.2 — Token API router

**Описание:** Создать FastAPI роутер для токенов.

**Файл:** `backend/src/api/routes/tokens.py`

**Реализация:**
```python
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.responses import JSONResponse

from sqlalchemy.ext.asyncio import AsyncSession

from api.dependencies import get_session, verify_api_key
from api.schemas.tokens import (
    TokenBalanceResponse,
    SpendTokensRequest,
    SpendTokensResponse,
    ErrorResponse,
    TokenErrorCode,
)
from services.token_service import TokenService
from core.exceptions import (
    NotFoundError,
    InsufficientBalanceError,
    SubscriptionExpiredError,
)

router = APIRouter(prefix="/api/v1", tags=["tokens"])

@router.get(
    "/users/{user_id}/balance",
    response_model=TokenBalanceResponse,
    responses={
        404: {"model": ErrorResponse, "description": "User not found"},
    },
)
async def get_balance(
    user_id: int,
    session: AsyncSession = Depends(get_session),
    _api_key: str = Depends(verify_api_key),
) -> TokenBalanceResponse:
    """
    Get user's token balance and subscription status.

    Requires API key authentication.
    """
    service = TokenService(session)

    try:
        balance = await service.check_balance(user_id)
    except NotFoundError:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail={
                "error": TokenErrorCode.USER_NOT_FOUND,
                "message": f"User {user_id} not found",
            },
        )

    return TokenBalanceResponse(
        user_id=balance.user_id,
        token_balance=balance.token_balance,
        subscription_active=balance.subscription_active,
        subscription_end=balance.subscription_end,
        can_spend=balance.can_spend,
        reason=balance.reason,
    )

@router.post(
    "/users/{user_id}/spend",
    response_model=SpendTokensResponse,
    responses={
        400: {"model": ErrorResponse, "description": "Invalid request"},
        403: {"model": ErrorResponse, "description": "Subscription expired"},
        404: {"model": ErrorResponse, "description": "User not found"},
        409: {"model": ErrorResponse, "description": "Insufficient balance"},
    },
)
async def spend_tokens(
    user_id: int,
    request: SpendTokensRequest,
    session: AsyncSession = Depends(get_session),
    _api_key: str = Depends(verify_api_key),
) -> SpendTokensResponse:
    """
    Spend tokens from user's balance.

    Requires API key authentication.

    Error codes:
    - `insufficient_balance`: Not enough tokens
    - `subscription_expired`: No active subscription
    - `user_not_found`: User doesn't exist
    """
    service = TokenService(session)

    try:
        result = await service.spend_tokens(
            user_id=user_id,
            amount=request.amount,
            description=request.description,
            idempotency_key=request.idempotency_key,
            metadata=request.metadata,
        )
    except NotFoundError:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail={
                "error": TokenErrorCode.USER_NOT_FOUND,
                "message": f"User {user_id} not found",
            },
        )
    except SubscriptionExpiredError as e:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail={
                "error": TokenErrorCode.SUBSCRIPTION_EXPIRED,
                "message": str(e),
            },
        )
    except InsufficientBalanceError as e:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail={
                "error": TokenErrorCode.INSUFFICIENT_BALANCE,
                "message": f"Not enough tokens. Required: {e.required}, available: {e.available}",
                "details": {
                    "required": e.required,
                    "available": e.available,
                },
            },
        )

    return SpendTokensResponse(
        transaction_id=result.transaction_id,
        tokens_spent=result.tokens_spent,
        balance_before=result.balance_before,
        balance_after=result.balance_after,
    )
```

**DoD:**
- [ ] GET /users/{user_id}/balance
- [ ] POST /users/{user_id}/spend
- [ ] API key authentication
- [ ] Proper HTTP status codes
- [ ] Error responses with codes

---

### T8.2.3 — API authentication

**Описание:** Добавить API key аутентификацию.

**Файл:** `backend/src/api/dependencies.py` (обновление)

**Реализация:**
```python
from fastapi import Depends, HTTPException, status, Security
from fastapi.security import APIKeyHeader

from core.config import settings

api_key_header = APIKeyHeader(name="Authorization", auto_error=False)

async def verify_api_key(
    api_key: str | None = Security(api_key_header),
) -> str:
    """
    Verify API key from Authorization header.

    Expected format: Bearer {api_key}
    """
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Missing API key",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Extract token from "Bearer {token}"
    if api_key.startswith("Bearer "):
        token = api_key[7:]
    else:
        token = api_key

    if token != settings.API_SECRET_KEY:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key",
            headers={"WWW-Authenticate": "Bearer"},
        )

    return token

# Alternative: verify internal service token
async def verify_internal_token(
    api_key: str | None = Security(api_key_header),
) -> str:
    """Verify internal service-to-service token"""
    if not api_key or api_key != settings.INTERNAL_API_KEY:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid internal token",
        )
    return api_key
```

**Обновление config.py:**
```python
class Settings(BaseSettings):
    # ... existing ...

    # API Authentication
    API_SECRET_KEY: str = ""  # For external API access
    INTERNAL_API_KEY: str = ""  # For service-to-service
```

**DoD:**
- [ ] API key verification
- [ ] Bearer token format
- [ ] 401 for missing/invalid key
- [ ] Internal token for services
