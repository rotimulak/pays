# E9.2 — Scheduled Tasks

## Описание

Планировщик задач для автоматических операций с подписками.

---

## Tasks

### T9.2.1 — Task runner setup

**Описание:** Настроить планировщик задач.

**Файл:** `backend/src/tasks/__init__.py`

**Реализация:**
```python
"""
Scheduled tasks for subscription management.

Uses APScheduler for async task scheduling.
"""

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from apscheduler.triggers.interval import IntervalTrigger
import logging

from tasks.subscription_tasks import (
    check_expiring_subscriptions,
    process_auto_renewals,
    send_expiry_notifications,
)

logger = logging.getLogger(__name__)

scheduler = AsyncIOScheduler()

def setup_scheduler() -> None:
    """Configure scheduled tasks"""

    # Check for expiring subscriptions every hour
    scheduler.add_job(
        check_expiring_subscriptions,
        trigger=IntervalTrigger(hours=1),
        id="check_expiring_subscriptions",
        name="Check Expiring Subscriptions",
        replace_existing=True,
    )

    # Send expiry notifications daily at 10:00
    scheduler.add_job(
        send_expiry_notifications,
        trigger=CronTrigger(hour=10, minute=0),
        id="send_expiry_notifications",
        name="Send Expiry Notifications",
        replace_existing=True,
    )

    # Process auto-renewals daily at 00:05
    scheduler.add_job(
        process_auto_renewals,
        trigger=CronTrigger(hour=0, minute=5),
        id="process_auto_renewals",
        name="Process Auto Renewals",
        replace_existing=True,
    )

    logger.info("Scheduler configured with subscription tasks")

def start_scheduler() -> None:
    """Start the scheduler"""
    setup_scheduler()
    scheduler.start()
    logger.info("Scheduler started")

def stop_scheduler() -> None:
    """Stop the scheduler"""
    scheduler.shutdown()
    logger.info("Scheduler stopped")
```

**Интеграция с FastAPI:**
```python
# main.py (FastAPI app)
from contextlib import asynccontextmanager
from fastapi import FastAPI

from tasks import start_scheduler, stop_scheduler

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    start_scheduler()
    yield
    # Shutdown
    stop_scheduler()

app = FastAPI(lifespan=lifespan)
```

**DoD:**
- [ ] APScheduler настроен
- [ ] Задачи зарегистрированы с правильными триггерами
- [ ] start/stop через FastAPI lifespan
- [ ] Логирование

---

### T9.2.2 — Subscription tasks

**Описание:** Реализовать задачи для подписок.

**Файл:** `backend/src/tasks/subscription_tasks.py`

**Реализация:**
```python
"""Subscription management tasks"""

import logging
from datetime import datetime

from db.session import async_session_factory
from services.subscription_service import SubscriptionService
from services.notification_service import NotificationService
from bot import get_bot

logger = logging.getLogger(__name__)

async def check_expiring_subscriptions() -> None:
    """
    Check for subscriptions expiring soon.
    Logs stats for monitoring.
    """
    logger.info("Starting expiring subscriptions check")

    async with async_session_factory() as session:
        service = SubscriptionService(session)

        # Check different time windows
        expiring_today = await service.get_expiring_subscriptions(days_ahead=0)
        expiring_3_days = await service.get_expiring_subscriptions(days_ahead=3)
        expiring_7_days = await service.get_expiring_subscriptions(days_ahead=7)

        logger.info(
            f"Expiring subscriptions: "
            f"today={len(expiring_today)}, "
            f"3_days={len(expiring_3_days)}, "
            f"7_days={len(expiring_7_days)}"
        )

async def send_expiry_notifications() -> None:
    """
    Send notifications to users with expiring subscriptions.
    """
    logger.info("Starting expiry notifications")

    bot = get_bot()

    async with async_session_factory() as session:
        service = SubscriptionService(session)
        notification = NotificationService(bot)

        # Get subscriptions expiring in 1 and 3 days
        for days in [3, 1]:
            expiring = await service.get_expiring_subscriptions(days_ahead=days)

            for sub in expiring:
                # Only notify if exactly N days left
                if sub.days_left == days:
                    try:
                        await notification.notify_subscription_expiring(
                            user_id=sub.user_id,
                            days_left=days,
                        )
                        logger.info(
                            f"Sent expiry notification to {sub.user_id} ({days} days)"
                        )
                    except Exception as e:
                        logger.error(
                            f"Failed to notify {sub.user_id}: {e}"
                        )

        # Notify about just-expired subscriptions
        expired = await service.get_expired_subscriptions()
        for user in expired:
            try:
                await notification.notify_subscription_expired(user.id)
                logger.info(f"Sent expired notification to {user.id}")
            except Exception as e:
                logger.error(f"Failed to notify {user.id}: {e}")

        await session.commit()

    logger.info("Expiry notifications completed")

async def process_auto_renewals() -> None:
    """
    Process automatic subscription renewals.
    """
    logger.info("Starting auto-renewals processing")

    bot = get_bot()

    async with async_session_factory() as session:
        service = SubscriptionService(session)
        notification = NotificationService(bot)
        service.set_notification_service(notification)

        stats = await service.process_all_renewals()

        await session.commit()

    logger.info(
        f"Auto-renewals completed: "
        f"total={stats['total']}, "
        f"successful={stats['successful']}, "
        f"failed={stats['failed']}"
    )

    # Log errors for investigation
    for error in stats.get("errors", []):
        logger.warning(f"Renewal error: user={error['user_id']}, {error['error']}")
```

**DoD:**
- [ ] check_expiring_subscriptions с логированием
- [ ] send_expiry_notifications за 3 и 1 день
- [ ] process_auto_renewals с обработкой ошибок
- [ ] Graceful error handling

---

### T9.2.3 — Manual task runner

**Описание:** CLI для ручного запуска задач.

**Файл:** `backend/scripts/run_task.py`

**Реализация:**
```python
"""
Manual task runner for debugging and maintenance.

Usage:
    # Check expiring subscriptions
    python -m scripts.run_task check_expiring

    # Send notifications
    python -m scripts.run_task send_notifications

    # Process renewals
    python -m scripts.run_task process_renewals

    # Dry run (show what would happen)
    python -m scripts.run_task process_renewals --dry-run
"""

import asyncio
import argparse
import logging

from tasks.subscription_tasks import (
    check_expiring_subscriptions,
    send_expiry_notifications,
    process_auto_renewals,
)

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)

TASKS = {
    "check_expiring": check_expiring_subscriptions,
    "send_notifications": send_expiry_notifications,
    "process_renewals": process_auto_renewals,
}

async def main():
    parser = argparse.ArgumentParser(description="Run subscription tasks manually")
    parser.add_argument("task", choices=TASKS.keys(), help="Task to run")
    parser.add_argument("--dry-run", action="store_true", help="Show what would happen")

    args = parser.parse_args()

    if args.dry_run:
        print(f"DRY RUN: Would run '{args.task}'")
        # TODO: Implement dry-run for each task
        return

    task_func = TASKS[args.task]
    print(f"Running task: {args.task}")

    await task_func()

    print(f"Task completed: {args.task}")

if __name__ == "__main__":
    asyncio.run(main())
```

**DoD:**
- [ ] CLI для ручного запуска
- [ ] Все задачи доступны
- [ ] Dry-run режим
- [ ] Понятный вывод
