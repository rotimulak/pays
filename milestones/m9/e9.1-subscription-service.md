# E9.1 — Subscription Service

## Описание

Сервис для управления подписками: проверка истечения, автопродление.

---

## Tasks

### T9.1.1 — Subscription service core

**Описание:** Создать сервис управления подписками.

**Файл:** `backend/src/services/subscription_service.py`

**Реализация:**
```python
from datetime import datetime, timedelta
from dataclasses import dataclass
from uuid import UUID
import logging

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_

from db.repositories.user_repository import UserRepository
from db.repositories.transaction_repository import TransactionRepository
from db.models.user import User
from db.models.transaction import TransactionType
from services.notification_service import NotificationService
from services.audit_service import AuditService
from core.config import settings
from core.exceptions import InsufficientBalanceError

logger = logging.getLogger(__name__)

@dataclass
class ExpiringSubscription:
    """User with expiring subscription"""
    user_id: int
    subscription_end: datetime
    days_left: int
    token_balance: int

@dataclass
class RenewalResult:
    """Result of auto-renewal attempt"""
    user_id: int
    success: bool
    new_end: datetime | None = None
    tokens_spent: int = 0
    error: str | None = None

class SubscriptionService:
    """Service for subscription management"""

    def __init__(self, session: AsyncSession):
        self.session = session
        self.user_repo = UserRepository(session)
        self.transaction_repo = TransactionRepository(session)
        self.notification_service: NotificationService | None = None
        self.audit_service = AuditService(session)

    def set_notification_service(self, service: NotificationService) -> None:
        self.notification_service = service

    async def get_expiring_subscriptions(
        self,
        days_ahead: int = 3,
    ) -> list[ExpiringSubscription]:
        """
        Find subscriptions expiring within N days.

        Args:
            days_ahead: How many days ahead to check

        Returns:
            List of expiring subscriptions
        """
        now = datetime.utcnow()
        cutoff = now + timedelta(days=days_ahead)

        result = await self.session.execute(
            select(User)
            .where(User.subscription_end.isnot(None))
            .where(User.subscription_end > now)
            .where(User.subscription_end <= cutoff)
            .where(User.is_blocked == False)
        )

        users = result.scalars().all()

        return [
            ExpiringSubscription(
                user_id=u.id,
                subscription_end=u.subscription_end,
                days_left=(u.subscription_end - now).days,
                token_balance=u.token_balance,
            )
            for u in users
        ]

    async def get_expired_subscriptions(self) -> list[User]:
        """Find users with just-expired subscriptions (for notification)"""
        now = datetime.utcnow()
        yesterday = now - timedelta(days=1)

        result = await self.session.execute(
            select(User)
            .where(User.subscription_end.isnot(None))
            .where(User.subscription_end <= now)
            .where(User.subscription_end > yesterday)
            .where(User.is_blocked == False)
        )

        return list(result.scalars().all())

    async def check_subscription_status(self, user_id: int) -> dict:
        """Get detailed subscription status"""
        user = await self.user_repo.get_by_id(user_id)
        if not user:
            raise NotFoundError(f"User {user_id} not found")

        now = datetime.utcnow()

        if user.subscription_end is None:
            return {
                "status": "none",
                "active": False,
                "message": "Подписка не оформлена",
            }

        if user.subscription_end <= now:
            expired_days = (now - user.subscription_end).days
            return {
                "status": "expired",
                "active": False,
                "expired_at": user.subscription_end,
                "expired_days_ago": expired_days,
                "message": f"Подписка истекла {expired_days} дней назад",
            }

        days_left = (user.subscription_end - now).days

        if days_left <= 1:
            status = "expiring_today"
        elif days_left <= 3:
            status = "expiring_soon"
        else:
            status = "active"

        return {
            "status": status,
            "active": True,
            "expires_at": user.subscription_end,
            "days_left": days_left,
            "message": f"Активна до {user.subscription_end.strftime('%d.%m.%Y')}",
        }
```

**DoD:**
- [ ] get_expiring_subscriptions работает
- [ ] get_expired_subscriptions для уведомлений
- [ ] check_subscription_status с детальным статусом
- [ ] Логирование

---

### T9.1.2 — Auto-renewal logic

**Описание:** Реализовать автопродление подписки.

**Добавление в SubscriptionService:**
```python
async def process_auto_renewal(
    self,
    user_id: int,
    renewal_price: int | None = None,
    renewal_days: int | None = None,
) -> RenewalResult:
    """
    Attempt to auto-renew subscription.

    Args:
        user_id: User to renew
        renewal_price: Token price (default from settings)
        renewal_days: Days to add (default from settings)

    Returns:
        RenewalResult with success/failure info
    """
    price = renewal_price or settings.SUBSCRIPTION_RENEWAL_PRICE
    days = renewal_days or settings.SUBSCRIPTION_RENEWAL_DAYS

    # Get user with lock
    user = await self.user_repo.get_for_update(user_id)
    if not user:
        return RenewalResult(
            user_id=user_id,
            success=False,
            error="User not found",
        )

    # Check balance
    if user.token_balance < price:
        logger.info(
            f"Auto-renewal failed for user {user_id}: "
            f"insufficient balance ({user.token_balance} < {price})"
        )

        # Notify about failed renewal
        if self.notification_service:
            await self.notification_service.notify_renewal_failed(
                user_id=user_id,
                reason="insufficient_balance",
                required=price,
                available=user.token_balance,
            )

        return RenewalResult(
            user_id=user_id,
            success=False,
            error=f"Insufficient balance: need {price}, have {user.token_balance}",
        )

    old_balance = user.token_balance
    old_end = user.subscription_end

    # Calculate new end date
    now = datetime.utcnow()
    if user.subscription_end and user.subscription_end > now:
        new_end = user.subscription_end + timedelta(days=days)
    else:
        new_end = now + timedelta(days=days)

    # Update balance
    new_balance = old_balance - price
    await self.user_repo.update_balance(
        user_id=user_id,
        delta=-price,
        expected_version=user.balance_version,
    )

    # Update subscription
    await self.user_repo.update_subscription(user_id, new_end)

    # Create transaction
    await self.transaction_repo.create(
        user_id=user_id,
        type=TransactionType.SUBSCRIPTION,
        tokens_delta=-price,
        balance_after=new_balance,
        description=f"Автопродление подписки на {days} дней",
        metadata={
            "renewal_type": "auto",
            "days": days,
            "old_end": old_end.isoformat() if old_end else None,
            "new_end": new_end.isoformat(),
        },
    )

    # Audit log
    await self.audit_service.log_action(
        action="subscription.renewed",
        entity_type="user",
        entity_id=str(user_id),
        user_id=user_id,
        old_value={"subscription_end": old_end.isoformat() if old_end else None},
        new_value={"subscription_end": new_end.isoformat()},
        metadata={"tokens_spent": price, "days": days},
    )

    # Notify success
    if self.notification_service:
        await self.notification_service.notify_renewal_success(
            user_id=user_id,
            new_end=new_end,
            tokens_spent=price,
        )

    logger.info(
        f"Auto-renewal successful for user {user_id}: "
        f"{old_end} → {new_end}, spent {price} tokens"
    )

    return RenewalResult(
        user_id=user_id,
        success=True,
        new_end=new_end,
        tokens_spent=price,
    )

async def process_all_renewals(self) -> dict:
    """
    Process auto-renewals for all eligible users.

    Returns:
        Stats dict with success/failure counts
    """
    # Find users with subscription ending today
    expiring = await self.get_expiring_subscriptions(days_ahead=0)

    stats = {
        "total": len(expiring),
        "successful": 0,
        "failed": 0,
        "errors": [],
    }

    for sub in expiring:
        try:
            result = await self.process_auto_renewal(sub.user_id)
            if result.success:
                stats["successful"] += 1
            else:
                stats["failed"] += 1
                stats["errors"].append({
                    "user_id": sub.user_id,
                    "error": result.error,
                })
        except Exception as e:
            logger.error(f"Error processing renewal for {sub.user_id}: {e}")
            stats["failed"] += 1
            stats["errors"].append({
                "user_id": sub.user_id,
                "error": str(e),
            })

    logger.info(f"Auto-renewal completed: {stats}")
    return stats
```

**DoD:**
- [ ] process_auto_renewal работает
- [ ] Проверка баланса перед списанием
- [ ] Транзакция типа SUBSCRIPTION
- [ ] Уведомления при успехе и неудаче
- [ ] process_all_renewals для batch processing

---

### T9.1.3 — User settings for auto-renewal

**Описание:** Добавить настройку автопродления пользователю.

**Обновление модели User:**
```python
# db/models/user.py
class User(Base):
    # ... existing fields ...

    auto_renew_enabled: Mapped[bool] = mapped_column(
        Boolean,
        default=True,
        comment="Enable automatic subscription renewal",
    )

    auto_renew_tariff_id: Mapped[UUID | None] = mapped_column(
        ForeignKey("tariffs.id"),
        nullable=True,
        comment="Tariff to use for auto-renewal",
    )
```

**Обновление SubscriptionService:**
```python
async def process_auto_renewal(self, user_id: int, ...) -> RenewalResult:
    # ... get user ...

    # Check if auto-renewal is enabled
    if not user.auto_renew_enabled:
        return RenewalResult(
            user_id=user_id,
            success=False,
            error="Auto-renewal disabled by user",
        )

    # Use user's preferred tariff or default
    if user.auto_renew_tariff_id:
        tariff = await self.tariff_repo.get_by_id(user.auto_renew_tariff_id)
        if tariff and tariff.is_active:
            price = tariff.tokens  # Use tariff token price
            days = tariff.subscription_days

    # ... rest of renewal logic ...

async def set_auto_renewal(
    self,
    user_id: int,
    enabled: bool,
    tariff_id: UUID | None = None,
) -> None:
    """Update user's auto-renewal settings"""
    user = await self.user_repo.get_by_id(user_id)
    if not user:
        raise NotFoundError(f"User {user_id} not found")

    user.auto_renew_enabled = enabled
    user.auto_renew_tariff_id = tariff_id

    await self.session.flush()

    await self.audit_service.log_action(
        action="subscription.settings_changed",
        entity_type="user",
        entity_id=str(user_id),
        user_id=user_id,
        new_value={
            "auto_renew_enabled": enabled,
            "auto_renew_tariff_id": str(tariff_id) if tariff_id else None,
        },
    )
```

**DoD:**
- [ ] auto_renew_enabled поле в User
- [ ] auto_renew_tariff_id для выбора тарифа
- [ ] set_auto_renewal для изменения настроек
- [ ] Проверка настроек перед продлением
- [ ] Миграция для новых полей
